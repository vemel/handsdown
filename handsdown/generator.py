import re
import logging
from pathlib import Path
from typing import Iterable, Text, List, Optional, Union

from handsdown.loader import Loader, LoaderError
from handsdown.processors.smart import SmartDocstringProcessor
from handsdown.processors.base import BaseDocstringProcessor
from handsdown.module_record import ModuleRecord, ModuleObjectRecord, ModuleRecordList
from handsdown.md_document import MDDocument
from handsdown.utils import get_title_from_path_part
from handsdown.path_finder import PathFinder


class GeneratorError(Exception):
    """
    Main error for `Generator`
    """


class Generator:
    """
    Main handsdown doc generator.

    Arguments:
        input_path -- Path to repo to generate docs.
        output_path -- Path to folder with auto-generated docs to output.
        source_paths -- List of paths to source files for generation.
        logger -- Logger instance.
        docstring_processor -- Docstring converter to Markdown.
        loader -- Loader for python modules.
        raise_errors -- Raise `LoaderError` instead of silencing in.
        ignore_unknown_errors -- Continue on any error.

    Arguments:
        LOGGER_NAME -- Name of logger: `handsdown`
        INDEX_NAME -- Docs index filename: `README.md`
        INDEX_TITLE -- Docs index title: `Index`
        INDEX_MODULES_NAME -- Modules ToC name in index: `Modules`
    """

    LOGGER_NAME = "handsdown"
    INDEX_NAME = "README.md"
    INDEX_TITLE = "Index"
    MODULES_NAME = "Modules"
    _short_link_re = re.compile(r"`+\S+`+")

    def __init__(
        self,
        input_path: Path,
        output_path: Path,
        source_paths: Iterable[Path],
        logger: Optional[logging.Logger] = None,
        docstring_processor: Optional[BaseDocstringProcessor] = None,
        loader: Optional[Loader] = None,
        raise_errors: bool = False,
    ) -> None:
        self._logger = logger or logging.Logger(self.LOGGER_NAME)
        self._root_path = input_path
        self._output_path = output_path
        self._project_name = get_title_from_path_part(input_path.name)
        self._index_path = Path(self._output_path, self.INDEX_NAME)
        self._root_path_finder = PathFinder(self._root_path / "_")

        # create output folder if it does not exist
        if not self._output_path.exists():
            self._logger.info(f"Creating folder {self._output_path}")
            self._output_path.mkdir(parents=True)

        self._raise_errors = raise_errors
        self._loader = loader or Loader(
            root_path=self._root_path,
            output_path=self._output_path,
            logger=self._logger,
        )
        self._docstring_processor = docstring_processor or SmartDocstringProcessor()

        self._source_paths = sorted(source_paths)
        self._module_records = self._build_module_record_list()

        package_names = self._module_records.get_package_names()
        package_names_re_expr = "|".join(package_names)
        self._docstring_links_re = re.compile(
            f"`+((?:{package_names_re_expr})\\.\\S+)`+"
        )
        self._signature_links_re = re.compile(
            f"[ \\[]((?:{package_names_re_expr})\\.[^() :,]+)"
        )

    def _build_module_record_list(self) -> ModuleRecordList:
        module_record_list = ModuleRecordList()
        for source_path in self._source_paths:
            module_record = None
            try:
                module_record = self._loader.get_module_record(source_path)
            except LoaderError as e:
                if self._raise_errors:
                    raise

                self._logger.warning(
                    f"Skipping {self._root_path_finder.relative(source_path)} due to import error: {e}"
                )

            if module_record:
                module_record_list.add(module_record)

        return module_record_list

    def cleanup_old_docs(self) -> None:
        """
        Remove old docs generated for this module.
        """
        self._logger.debug(f"Removing orphaned docs")
        preserve_paths = {i.output_path for i in self._module_records}
        for doc_path in self._output_path.glob("**/*.md"):
            if doc_path == self._index_path:
                continue

            if doc_path in preserve_paths:
                continue

            file_content = doc_path.read_text()
            is_autogenerated = "> Auto-generated documentation" in file_content
            if is_autogenerated:
                self._logger.info(
                    f"Deleting orphaned doc file {self._root_path_finder.relative(doc_path)}"
                )
                doc_path.unlink()

                # remove parent directory if it is empty
                try:
                    doc_path.parent.rmdir()
                except OSError:
                    continue
                else:
                    self._logger.info(
                        f"Deleting orphaned directory {self._root_path_finder.relative(doc_path.parent)}"
                    )

    def generate_doc(self, source_path: Path) -> None:
        """
        Generate one module doc at once.

        Arguments:
            source_path -- Path to source file.

        Raises:
            GeneratorError -- If `source_path` not found in current repo.
        """
        for module_record in self._module_records:
            if module_record.source_path != source_path:
                continue

            with MDDocument(module_record.output_path) as md_document:
                self._generate_doc(module_record, md_document)
                self._replace_short_links(module_record, md_document)
                self._replace_full_links(md_document)

            return

        raise GeneratorError(f"Record not found for {source_path.name}")

    def _generate_doc(
        self, module_record: ModuleRecord, md_document: MDDocument
    ) -> None:
        self._logger.debug(
            f"Generating doc {self._root_path_finder.relative(md_document.path)}"
            f" for {self._root_path_finder.relative(module_record.source_path)}"
        )

        source_link = md_document.render_doc_link(
            title=f"{module_record.import_string}",
            target_path=module_record.source_path,
        )
        md_document.title = module_record.title
        md_document.subtitle = (
            f"> Auto-generated documentation for {source_link} module."
        )

        self._render_docstring(module_record=module_record, md_document=md_document)

        self._generate_module_doc_lines(module_record, md_document)
        md_document.ensure_toc_exists()

        modules_toc_lines = self._build_modules_toc_lines(
            module_record.import_string, max_depth=3, md_document=md_document
        )

        toc_lines = md_document.toc_section.split("\n")
        breadscrumbs = self._build_breadcrumbs_string(
            module_record=module_record, md_document=md_document
        )
        toc_lines[0] = f"- {breadscrumbs}"
        if modules_toc_lines:
            toc_lines.append(f"  - {self.MODULES_NAME}")
            for line in modules_toc_lines:
                toc_lines.append(f"    {line}")

        md_document.toc_section = "\n".join(toc_lines)

        md_document.write()

    def _build_breadcrumbs_string(
        self, module_record: ModuleRecord, md_document: MDDocument
    ) -> Text:
        breadcrumbs: List[Text] = []

        import_string_parts = module_record.get_import_string_parts()
        parent_import_parts: List[Text] = []
        for part in import_string_parts:
            parent_import_parts.append(part)
            parent_import = ".".join(parent_import_parts)
            parend_module_record = self._module_records.find_object(parent_import)
            if not parend_module_record:
                breadcrumbs.append(f"`{get_title_from_path_part(part)}`")
                continue

            breadcrumbs.append(
                md_document.render_doc_link(
                    parend_module_record.title,
                    target_path=parend_module_record.output_path,
                    anchor=parend_module_record.title,
                )
            )

        breadcrumbs.append(module_record.title)
        breadcrumbs.insert(
            0,
            md_document.render_doc_link(
                self.INDEX_TITLE,
                target_path=self._output_path / self.INDEX_NAME,
                anchor=f"{self._project_name} {self.INDEX_TITLE}",
            ),
        )

        return " / ".join(breadcrumbs)

    def generate_docs(self) -> None:
        """
        Generate all doc files at once.
        """
        self._logger.debug(
            f"Generating docs for {self._project_name} to"
            f" {self._root_path_finder.relative(self._output_path)}"
        )

        for module_record in self._module_records:
            with MDDocument(module_record.output_path) as md_document:
                self._generate_doc(module_record, md_document)
                self._replace_short_links(module_record, md_document)
                self._replace_full_links(md_document)

    def generate_index(self) -> None:
        """
        Generate `<output>/README.md` file with title from `<root>/README.md` and `Modules`
        section that contains a Tree of all modules in the project.
        """
        self._logger.debug(
            f"Generating {self._root_path_finder.relative(self._index_path)}"
        )
        md_document = MDDocument(self._output_path / self.INDEX_NAME)
        md_document.title = f"{self._project_name} {self.INDEX_TITLE}"

        md_document.subtitle = "> Auto-generated documentation index."
        md_document.ensure_toc_exists()

        modules_toc_lines = self._build_modules_toc_lines(
            "", max_depth=3, md_document=md_document
        )
        if modules_toc_lines:
            toc_lines = md_document.toc_section.split("\n")
            for line in modules_toc_lines:
                toc_lines.append(f"  {line}")

            md_document.toc_section = "\n".join(toc_lines)

        md_document.write()

    def _replace_short_links(
        self, module_record: ModuleRecord, md_document: MDDocument
    ) -> None:
        if not module_record.objects:
            return

        sections = md_document.sections

        for index, section in enumerate(sections):
            for match in self._short_link_re.findall(section):
                import_string = match.replace("`", "")
                for module_object in module_record.objects:
                    if module_object.import_string != import_string:
                        continue

                    title = module_object.title
                    link = md_document.render_doc_link(
                        title, anchor=title, target_path=module_object.output_path
                    )
                    section = section.replace(match, link)
                    self._logger.debug(
                        f"Adding local link '{title}' to"
                        f" {self._root_path_finder.relative(md_document.path)}"
                    )
            sections[index] = section

    def _replace_full_links(self, md_document: MDDocument) -> None:
        sections = md_document.sections

        for index, section in enumerate(sections):
            for match in re.findall(self._docstring_links_re, section):
                module_object = self._module_records.find_object(match)
                if module_object is None:
                    continue

                title = module_object.title
                link = md_document.render_doc_link(
                    title, anchor=title, target_path=module_object.output_path
                )
                section = section.replace(match, link)
                self._logger.debug(
                    f"Adding link '{title}' to"
                    f" {self._root_path_finder.relative(md_document.path)}"
                )
            sections[index] = section

    def _generate_module_doc_lines(
        self, module_record: ModuleRecord, md_document: MDDocument
    ) -> None:
        for module_object_record in module_record.objects:
            if module_object_record.is_related:
                continue

            md_document.append_title(
                module_object_record.title, level=module_object_record.level + 2
            )

            source_path = module_object_record.source_path
            source_link = md_document.render_doc_link(
                title="ðŸ” find in source code",
                target_path=source_path,
                anchor=f"L{module_object_record.source_line_number}",
            )
            md_document.append(source_link)

            signature = module_object_record.signature

            if signature:
                md_document.append(f"```python\n{signature}\n```")

            self._render_docstring(
                module_record=module_object_record,
                signature=signature,
                md_document=md_document,
            )

    def _render_docstring(
        self,
        module_record: Union[ModuleRecord, ModuleObjectRecord],
        md_document: MDDocument,
        signature: Optional[Text] = None,
    ) -> Optional[Text]:
        """
        Get object docstring and convert it to a valid markdown using
        `handsdown.processors.base.BaseDocstringProcessor`.

        Arguments:
            source_path -- Path to object source file.
            module_object -- Object to inspect.
            signature -- Object signature if exists.

        Returns:
            A module docstring with valid markdown.
        """
        docstring = module_record.docstring
        if not docstring:
            return

        title, docstring = md_document.extract_title(docstring)
        if title:
            module_record.title = title
            md_document.title = title

        section_map = self._docstring_processor.build_sections(docstring)
        if signature:
            related_objects = self._get_objects_from_signature(signature)
            for related_object in related_objects:
                if related_object is module_record:
                    continue

                title = related_object.title
                link = md_document.render_doc_link(
                    title, anchor=title, target_path=related_object.output_path
                )
                section_map.add_line("See also", f"- {link}")
                self._logger.debug(
                    f"Adding link '{title}' to"
                    f" {self._root_path_finder.relative(related_object.output_path)} 'See also' section"
                )

        for section in section_map.sections:
            if section.title:
                md_document.append_title(section.title, level=4)
            md_document.append(section.render())

    def _get_objects_from_signature(self, signature: Text) -> List[ModuleObjectRecord]:
        result: List[ModuleObjectRecord] = []
        for match in re.findall(self._signature_links_re, signature):
            module_object_record = self._module_records.find_object(match)
            if not module_object_record or module_object_record in result:
                continue

            result.append(module_object_record)

        return result

    def _build_modules_toc_lines(
        self, import_string: Text, max_depth: int, md_document: MDDocument
    ) -> List[Text]:
        lines: List[Text] = []
        parts: List[Text] = []
        if import_string:
            parts = import_string.split(".")

        last_import_string_parts: List[Text] = []
        for module_record in self._module_records:
            if module_record.import_string == import_string:
                continue

            if not module_record.import_string.startswith(import_string):
                continue

            if len(module_record.import_string.split(".")) > len(parts) + max_depth:
                continue

            title_parts = module_record.get_title_parts()
            import_string_parts = module_record.get_import_string_parts()
            for index, title_part in enumerate(title_parts[:-1]):
                if index < len(parts):
                    continue

                if (
                    len(last_import_string_parts) > index
                    and last_import_string_parts[index] == import_string_parts[index]
                ):
                    continue
                indent = "  " * (index - len(parts))
                lines.append(f"{indent}- {title_part}")

            last_import_string_parts = import_string_parts
            indent = "  " * (len(title_parts) - len(parts) - 1)
            link = md_document.render_doc_link(
                title=title_parts[-1],
                anchor=title_parts[-1],
                target_path=module_record.output_path,
            )
            lines.append(f"{indent}- {link}")
        return lines
